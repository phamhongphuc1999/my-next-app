/* eslint-disable quotes */
import verificationImg from 'public/images/master-thesis/chapter4/verification-process.png';
import { AppArticle, ArticleLI, ArticleUL } from 'src/components/box/ArticleBox';
import AlgorithmBox from 'src/components/Thesis/AlgorithmBox';
import FigureBox from 'src/components/Thesis/FigureBox';
import RefLink from 'src/components/Thesis/RefLink';
import { SubsectionBox } from 'src/components/Thesis/SectionBox';
import { generateProofCode, theFirstStageCode } from './code';

export default function ProposedProcess() {
  return (
    <SubsectionBox
      id="the-proposed-confirm-change-owner"
      title="The proposed confirm change owner process"
    >
      <AppArticle isFirst>
        In <RefLink toId="guardian-based-account-abstraction-recovery-mechanism" mode="section" />
        {
          ', we discussed the guardian mechanism. In this section, we explain the latest process from the previous section: the confirming change owner process. This proposed process is divided into two sub-processes'
        }
      </AppArticle>
      <ArticleUL className="list-disc">
        <ArticleLI>
          <span className="italic">Creation proof process</span>
          {
            ': This occurs off-chain, where guardians generate their proof and submit it to the smart contract.'
          }
        </ArticleLI>
        <ArticleLI>
          <span className="italic">Verification proof process</span>
          {
            ": The smart contract validates the guardian's proof, and when all requirements are met, the system unlocks the change-owner transaction."
          }
        </ArticleLI>
      </ArticleUL>
      <FigureBox
        src={verificationImg}
        id="creation-and-verification-proof-process"
        alt="creation-and-verification-proof-process"
        title="Creation and verification proof processes"
      />
      <AppArticle isFirst>
        <RefLink toId="creation-and-verification-proof-process" />
        {
          ' illustrates the creation proof and the verification proof processes. Normally, both Poseidon hash function and EdDSA do not require a fixed-size message as input. However, since circuits are static and do not support variable-length inputs, a fixed-size message is required. In this thesis, we define the fixed size to be 256 bits. Therefore, the proof creation process uses a fixed-size combination of increment and _tempNewOwner as input. In detail, the 256-bit message consists of two parts:'
        }
      </AppArticle>
      <ArticleUL className="list-disc">
        <ArticleLI>
          {
            'The first 64-bit is padded increment, which is extended to 64 bits by adding zeros in front of it.'
          }
        </ArticleLI>
        <ArticleLI>
          {
            'The remaining 192 bits are padded _tempNewOwner, likely to increment, _tempNewOwner is padded to 192 bits by adding zeros in front of it.'
          }
        </ArticleLI>
      </ArticleUL>
      <AppArticle>
        {
          'This fixed-size message is then signed using EdDSA. Next, the proof generator takes the signature and the public key as inputs to create a zk-SNARK proof. All of this can happen off-chain. While anyone, including non-guardians, can generate a proof, only proofs created by guardians are accepted based on zk-SNARK protocol. In this setup, guardians act as provers attempting to convince the verifier, which is a smart contract.'
        }
      </AppArticle>
      <AlgorithmBox algorithm={generateProofCode} id="generate-proof" title="Generate proof" />
      <AppArticle isMath isFirst>
        {'However, proof generated by '}
        <RefLink toId="generate-proof" mode="algorithm" />
        {
          ' cannot be directly submitted to the smart contract for verification. Before submission, the proof must be converted into three parameters: $pA$, $pB$, and $pC$. Here, $pA$ and $pC$ are elements in $G_1$, derived from the zk-SNARK proof, and used in the pairing check. $pB = [pB_1, pB_2]$, where both $pB_1$ and $pB_2$ are elements in the target group $G_T$ of the elliptic curve pairing.'
        }
      </AppArticle>
      <AppArticle isMath>
        {
          'The converted proof ($pA$, $pB$, $pC$, and publicSignals) is then submitted to the smart contract for verification, which is divided into two stages.'
        }
      </AppArticle>
      <AppArticle>
        {
          "In the first stage, firstly, the process checks whether there is enough confirmation or not; if they are enough, every following step will be stopped. Secondly, the smart contract verifies that the submitted proof belongs to a guardian and confirms that the signed message matches the current increment. Since the circuit was designed to output (or can be called public signals) the account address hash, the _tempNewOwner and the increment, this stage simply compares the proof's address hash with each guardian's hash stored in the smart contract, as well as the proof's increment and proof's _tempNewOwner with the current increment and current _tempNewOwner stored in the smart contract respectively. This stage acts as a barrier to block proofs submitted by non-guardians. Only the proof that comes from a guardian will be executed."
        }
      </AppArticle>
      <AlgorithmBox algorithm={theFirstStageCode} id="the-first-stage" title="The first stage" />
    </SubsectionBox>
  );
}
